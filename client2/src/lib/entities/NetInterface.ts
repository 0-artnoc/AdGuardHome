// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface INetInterface {
    flags?: string;
    gateway_ip?: string;
    hardware_address?: string;
    ipv4_addresses?: string[];
    ipv6_addresses?: string[];
    name?: string;
}

export default class NetInterface {
    readonly _flags: string | undefined;

    /**
     * Description: undefined
     * Example: up|broadcast|multicast
     */
    get flags(): string | undefined {
        return this._flags;
    }

    readonly _gateway_ip: string | undefined;

    get gatewayIp(): string | undefined {
        return this._gateway_ip;
    }

    readonly _hardware_address: string | undefined;

    /**
     * Description: undefined
     * Example: 52:54:00:11:09:ba
     */
    get hardwareAddress(): string | undefined {
        return this._hardware_address;
    }

    readonly _ipv4_addresses: string[] | undefined;

    get ipv4Addresses(): string[] | undefined {
        return this._ipv4_addresses;
    }

    readonly _ipv6_addresses: string[] | undefined;

    get ipv6Addresses(): string[] | undefined {
        return this._ipv6_addresses;
    }

    readonly _name: string | undefined;

    /**
     * Description: undefined
     * Example: eth0
     */
    get name(): string | undefined {
        return this._name;
    }

    constructor(props: INetInterface) {
        if (typeof props.flags === 'string') {
            this._flags = props.flags.trim();
        }
        if (typeof props.gateway_ip === 'string') {
            this._gateway_ip = props.gateway_ip.trim();
        }
        if (typeof props.hardware_address === 'string') {
            this._hardware_address = props.hardware_address.trim();
        }
        if (props.ipv4_addresses) {
            this._ipv4_addresses = props.ipv4_addresses;
        }
        if (props.ipv6_addresses) {
            this._ipv6_addresses = props.ipv6_addresses;
        }
        if (typeof props.name === 'string') {
            this._name = props.name.trim();
        }
    }

    serialize(): INetInterface {
        const data: INetInterface = {
        };
        if (typeof this._flags !== 'undefined') {
            data.flags = this._flags;
        }
        if (typeof this._gateway_ip !== 'undefined') {
            data.gateway_ip = this._gateway_ip;
        }
        if (typeof this._hardware_address !== 'undefined') {
            data.hardware_address = this._hardware_address;
        }
        if (typeof this._ipv4_addresses !== 'undefined') {
            data.ipv4_addresses = this._ipv4_addresses;
        }
        if (typeof this._ipv6_addresses !== 'undefined') {
            data.ipv6_addresses = this._ipv6_addresses;
        }
        if (typeof this._name !== 'undefined') {
            data.name = this._name;
        }
        return data;
    }

    validate(): string[] {
        const validateRequired = {
            flags: !this._flags ? true : typeof this._flags === 'string' && !this._flags ? true : this._flags,
            hardware_address: !this._hardware_address ? true : typeof this._hardware_address === 'string' && !this._hardware_address ? true : this._hardware_address,
            name: !this._name ? true : typeof this._name === 'string' && !this._name ? true : this._name,
            ipv4_addresses: !this._ipv4_addresses ? true : this._ipv4_addresses.reduce((result, p) => result && typeof p === 'string', true),
            ipv6_addresses: !this._ipv6_addresses ? true : this._ipv6_addresses.reduce((result, p) => result && typeof p === 'string', true),
            gateway_ip: !this._gateway_ip ? true : typeof this._gateway_ip === 'string' && !this._gateway_ip ? true : this._gateway_ip,
        };
        const isError: string[] = [];
        Object.keys(validateRequired).forEach((key) => {
            if (!(validateRequired as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props: INetInterface): NetInterface {
        return new NetInterface(props);
    }

    readonly keys: { [key: string]: string } = {
        flags: 'flags',
        gatewayIp: 'gateway_ip',
        hardwareAddress: 'hardware_address',
        ipv4Addresses: 'ipv4_addresses',
        ipv6Addresses: 'ipv6_addresses',
        name: 'name',
        }
;

    mergeDeepWith(props: Partial<NetInterface>): NetInterface {
        const updateData: Partial<INetInterface> = {};
        Object.keys(props).forEach((key: keyof NetInterface) => {
            const updateKey = this.keys[key] as keyof INetInterface;
            if ((props[key] as any).serialize) {
                (updateData[updateKey] as any) = (props[key] as any).serialize() as Pick<INetInterface, keyof INetInterface>;
            } else {
                (updateData[updateKey] as any) = props[key];
            }
        });
        return new NetInterface({ ...this.serialize(), ...updateData });
    }
}
